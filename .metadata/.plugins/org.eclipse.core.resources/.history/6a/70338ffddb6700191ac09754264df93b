package gameEngine;

import static org.lwjgl.opengl.GL11.*;
import static org.lwjgl.opengl.GL15.*;
import static org.lwjgl.opengl.GL20.*;

import java.nio.*;

import  org.lwjgl.BufferUtils;
import org.lwjgl.opengl.GL;



/*
   This is to allow batch rendering we first just allocate buffers for the vertexes,uvcoords,and indeces then we use the method addvaluestoVBO() to add in a new model(don't forget to to make sure to change the positions so
   they are not rendered on top of each other) then in order to draw all the models in one draw call we call the method draw() after first calling the enable() to change values on the fly we put in the section and the target
   either v_id,tex_id,or ind_id and lastly the data in float array and integer array for v_id,tex_id and ind_id.  
*/

public class BatchedModel {
	 private int drawCount,drawCount2;
		public int v_id,tex_id,ind_id;//made these public so that we can get to them from another method to change values
	private int indBase,pionter,sections;
	
	
	public BatchedModel() {
		
		//setting everything to 0 
		
		drawCount=0;
		indBase=0;
		pionter=0;
		sections=0;
		//making space for buffers
		 v_id=glGenBuffers();//for vertices		
		   tex_id=glGenBuffers();//for uv Coords
			ind_id=glGenBuffers();//for indices  
			
		
		
		
		//all dynamic draw so we can change them on the fly
		glBindBuffer(GL_ARRAY_BUFFER,v_id);
		  glBufferData(GL_ARRAY_BUFFER,10000,GL_DYNAMIC_DRAW);
		
		 
	    glBindBuffer(GL_ARRAY_BUFFER,tex_id);
		  glBufferData(GL_ARRAY_BUFFER,10000,GL_DYNAMIC_DRAW);
			
		  
	    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,ind_id);
	      glBufferData(GL_ELEMENT_ARRAY_BUFFER,10000,GL_DYNAMIC_DRAW);
        
	      unbindBuffers();
		}
	
	
	public void draw() {
		
		glBindBuffer(GL_ARRAY_BUFFER,v_id);
		  glVertexAttribPointer(0,2,GL_FLOAT,false,0,0);
			
	   glBindBuffer(GL_ARRAY_BUFFER,tex_id);
		  glVertexAttribPointer(1,2,GL_FLOAT,false,0,0);
				
		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,ind_id);
	      glDrawElements(GL_TRIANGLES,drawCount,GL_UNSIGNED_INT,0);
	    
	  	
		}
	
	
	
public void addvaluestoVBO(float[] v,float[] uv) {//used to add a new model to the buffers
	if((v.length == uv.length) && v.length==8) {
		

	
	glBindBuffer(GL_ARRAY_BUFFER, v_id);
	 glBufferSubData(GL_ARRAY_BUFFER,pionter, makeBuffer(v));
//	glBindBuffer(GL_ARRAY_BUFFER,0);
	 
	glBindBuffer(GL_ARRAY_BUFFER, tex_id);
	 glBufferSubData(GL_ARRAY_BUFFER, pionter, makeBuffer(uv));
	//glBindBuffer(GL_ARRAY_BUFFER,0);
		
int[] indeces= new int[] {
			indBase,indBase+1,indBase+2,
			indBase+2,indBase+3,indBase	
			
			
			
			
	};
	
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,ind_id);
	 glBufferSubData(GL_ELEMENT_ARRAY_BUFFER,drawCount2, makeBuffer(indeces));//remember all offsets are in bytes so a int is 4 bytes and a float is as well so we need to multiply be 4 to get the correct offset 
  
	drawCount=drawCount+6;
	drawCount2=drawCount*4;
	
	indBase=indBase+4;
	 pionter=pionter+(8*4);
	sections++; 
	
	}
	
	
	
}
	
private static FloatBuffer makeBuffer(float[] array ) {
	FloatBuffer buffer= BufferUtils.createFloatBuffer(array.length); //this just is initializing our buffer with the correct capacity
	buffer.put(array);//puts the data in the newly created buffer
	buffer.flip();//this allows the buffer to be read from very very important 
	return buffer;
}
//same as float just integer this time

private static IntBuffer makeBuffer(int[] array ) {
	IntBuffer buffer= BufferUtils.createIntBuffer(array.length); 
	buffer.put(array);  
	buffer.flip();
	return buffer;
	
}	
	
	
public static void enable() {
	   glEnableVertexAttribArray(0);
	   glEnableVertexAttribArray(1);
}
public static void disable() {
	   glDisableVertexAttribArray(0);
    glDisableVertexAttribArray(1);
}

private static void unbindBuffers() {
	glBindBuffer(GL_ARRAY_BUFFER,0);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,0);		
	
}	
	
public void changevalues(int section,int target,float[] newValue) {
	if((newValue.length ==8 )&& ((target==v_id)||(target==tex_id))) {
		long tempfloat=(section*8)*4;
		
			glBindBuffer(GL_ARRAY_BUFFER,target);
			glBufferSubData(GL_ARRAY_BUFFER, tempfloat, makeBuffer(newValue));
		    glBindBuffer(GL_ARRAY_BUFFER,0);
		
		}
	
	
	
	
}
public void changevalues(int section,int target,int[] newValue) {
	if((newValue.length ==6 )&& (target==ind_id)) {
		long tempfloat=(section*6)*4;
		
			glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,target);
			glBufferSubData(GL_ELEMENT_ARRAY_BUFFER, tempfloat, makeBuffer(newValue));
		    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,0);
		
		}
	

	
	
}	
public void flushBuffers() {
   	
	glBindBuffer(GL_ARRAY_BUFFER,v_id);
	  glBufferData(GL_ARRAY_BUFFER,10000,GL_DYNAMIC_DRAW);
	
	 
  glBindBuffer(GL_ARRAY_BUFFER,tex_id);
	  glBufferData(GL_ARRAY_BUFFER,10000,GL_DYNAMIC_DRAW);
		
	  
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,ind_id);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER,10000,GL_DYNAMIC_DRAW);
    drawCount=0;
	indBase=0;
	pionter=0;
	sections=0;
    unbindBuffers();
	
	
	
}	
}
