package gameEngine;
import java.io.IOException;
import static org.lwjgl.glfw.GLFW.*;
import java.util.Map;

import org.joml.Matrix4f;
import  org.joml.Vector2f;
public class Start {
    
	
	public static Window w;	
	public static final int width=640,height=480;
    public static int location,Projection,RTS,frames,j=0,i=0,fps;
    public static byte dKeys,testKey;
    public static ShaderProgram s;
    public static Camera cam;
    public static Input I;
    public static Text font;
    public static boolean canRender,overworld=true;
    public static double framCap,time,time2,passed,unproccesed,frameTime;
    public static Texture tex,MAP,bg,playerTex;
    public static float x2,y2,camx,camy,x,y,Playerscale=64;
    public static Model background,player;
    
	public static void main(String[] args) {
		float[] vert={
				-0.5f,+0.5f,
				0.5f,0.5f,
				0.5f,-0.5f,
				-0.5f,-0.5f
			};
		
		
		
		
		
		
		
		float Texwidth=256;
		float Texheight=256;		
		float wi=64;
		float h=64;
		float Texx=64;
		float Texy=0;		
		
		float[] uv={
				Texx/Texwidth,Texy/Texheight,
				(Texx+wi)/Texwidth,Texy/Texheight,
				(Texx+wi)/Texwidth,(Texy+h)/Texheight,
				Texx/Texwidth,(Texy+h)/Texheight
				};
		
		
		float[] uvBg={
				0,0,
				1,0,
				1,1,
				0,1
				
				};
		
		
		
		
		
		
		
		
		
		
		
		
		
			
		int[] ind= {
			0,1,2,
			2,3,0	
				
		};
	   Texwidth=256;
	   Texheight=256;		
	   wi=32;
	   h=44;
	   Texx=0;
	   Texy=0;	


	   float[] vertPlayer={
             -0.5f,1,
			 1,1,
			 1,-0.5f,
			 -0.5f,-0.5f


	   };
	   


       float[] uvPlayer={
		Texx/Texwidth,Texy/Texheight,
		(Texx+wi)/Texwidth,Texy/Texheight,
		(Texx+wi)/Texwidth,(Texy+h)/Texheight,
		Texx/Texwidth,(Texy+h)/Texheight  };





		//for(int i=0;i<8;i++) {
		///System.out.println(uv[i]);
		//} 
		
		
		//make our window and attach shaders
		createWindow("shader");
	
		
		//Define textures
	    
		tex=new Texture("newsprite");
		bg= new Texture("testBackground");
	   font=new Text("aakar",512);
		
		
		
	//	MAP=new Texture("map3");
	    playerTex= new Texture("playerSprite2s");
		//map=new Texture("map1"); 
		//Define models
		Model m=new Model(vert,uv,ind);//model for tiles
		player= new Model(vertPlayer,uvPlayer,ind);
	    background=new Model(vert,uvBg,ind);
		
		
		//set camera
		cam= new Camera(width,height);
		
		//make shader locations so we can use uniforms
		try {
			location=s.makeLocation("sampler");
			Projection=s.makeLocation("projection");
			RTS=s.makeLocation("rts");
		} catch (Exception e) {
			
			e.printStackTrace();
		}
		World world=new World("map", 64,64, cam);
		Tiles t=new Tiles(tex, m, s, cam, location, Projection,RTS);
		
	    gameEngine.Map grid=new gameEngine.Map(world.Getmap(),t);
	
		
		
		
		 boolean map=true;
		initializeFPS();
		x=0;
		y=0;	
	
//----------------------game loop------------------------------
		while(!w.isExited() && !I.IsEscapePushed()) {
	
		fps();
	    t.unbind();
	

	if(canRender) {
	  // TextureUpdate(MAP);
		float tempx=x;
		float tempy=y;
		frames++;
if(overworld==true) {		 
		 
	    x=-camx;
	    y=-camy;
	     cam.setPosition((new Vector2f(camx,camy)));s.bind();
		 grid.Draw();	 
		 
		 font.text("x="+x+" y="+y,x-300,y-220,.24f);//prints the x and y positions on the screen	  
		
		 SpriteUpdate(player,playerTex,x,y,Playerscale,true);     
}else {
	//---------------------battle loop---------------------
	battleupdate();
	
	x=0;
	y=0;
	
	
}

font.text("fps="+(int)fps,(640/2)+x-100,(480/2)+y-20,.24f);
x=tempx;
y=tempy;
		    w.render();
		    w.clear();
			
		}
		}
//--------------------------------------------------------------		
		
		w.destroy();
		
		
	}

	private static void TextureUpdate(Texture tex) {

		byte b=I.getDirectionalInput();
		
			if(b==0x0001) {
			try {
				System.out.println("yes");
				tex.createFile(true,"map");
			} catch (IOException e) {
			
				e.printStackTrace();
			}
		}
		}
		
		
		
	

	private static void createWindow(String Shader) {
	 w=new Window(width,height);
	 I=new Input(w);	
       //load our shaders 
		s= new ShaderProgram(Shader);
		//bind shader
		s.bind();	
		
		
	}

	private static void Inputupdate() {
		w.update();//this is needed to actually poll events from keyboard 
		I.findKeys();
	    dKeys=I.getDirectionalInput();
	    
	   testKey=I.getStateofButton(GLFW_KEY_T);
	   float speed=1;
	    		
		byte stateofFullscreen=I.stateOfFullscreen();
	      if(stateofFullscreen==1) {//if the fuscreenCode is just pressed toggle full screen
			 w.toggleFullscreen();}
		
	if(testKey==2) {
		if (overworld==false) {
			overworld=true;
			
		}else {
			overworld=false;
			
		}
		
	}
	
	
	if(overworld==true) {
		        if(I.getStateofButton(GLFW_KEY_W)==1 || I.getStateofButton(GLFW_KEY_W)==3) {
		        	speed=5;
		        	
		        	
		        }else {
		        	speed=1;
		        	
		        	
		        }
		
		
				if((dKeys>>4 &0x01)==1) {//if c is pushed
					if((dKeys & 0x01)==1) {//up
						camy-=10;
						
					}
					if((dKeys>>1 & 0b001)==1) {//down
						camy+=10;
						
					}if((dKeys>>2 & 0b001)==1) {//left
						camx-=10;
						
					}if((dKeys>>3 & 0b001)==1) {//right
						camx+=10;}	 
					}else{ 
						if((dKeys & 0x01)==1) {//up
							y+=5*speed;
							
						}
						if((dKeys>>1 & 0b001)==1) {//down
							y-=5*speed;
							
						}if((dKeys>>2 & 0b001)==1) {//left
							x+=5*speed;
							
						}if((dKeys>>3 & 0b001)==1) {//right
							x-=5*speed;}	 
					camx=-x;
					camy=-y;
					
						}
		 
	}
		 
		 
			 }
	
	
   private static void battleupdate() {
	   cam.setPosition(new Vector2f(0,0));
		s.bind();
		bg.bind(0);
		  s.loadInt(location, 0);
		  cam.setPosition(new Vector2f(0,0));
	 	   s.loadMat(Projection,cam.getProjection());
	 	  s.loadMat(RTS,Math.getMatrix(new Vector2f(0,0),0,64*40));//change rotation and scale with this
	 	  background.draw();
	 	  SpriteUpdate(player,playerTex,-192,-20,64*1.5f,true); //doing the same model and texture just for testing  will change that when we actually get the battle system down  
	 	  SpriteUpdate(player,playerTex,-222,-128-20,64*1.5f,true);
	 	  SpriteUpdate(player,playerTex,222-20,-128+40,64*1.5f,false);
	 	   s.loadInt(location, 0);
	   
	   
   }
	
	private static void fps() {
		    canRender=false;//don't allow rendering until time
			time2=Timer.getTIme();//gets current time
		    passed=time2-time;//this is the time since the last time through the loop
			unproccesed+=passed;//this is the time that we have not rendered anything
			frameTime+=passed;//this is the time since the last second
			time=time2;
			while(unproccesed>=framCap) {//when the time we have not rendered is greater than or equal to our frame target we allow rendering
				
				unproccesed-=framCap;//this is like reseting but instead if it is way over for some reason it makes sure to allow all rendering missed 
			       
				//take input
				 Inputupdate();
			     canRender=true;//now we render	
			     
			      if(frameTime>=1.0) {//if a second has passed print fps
			    	 
			    	 // System.out.println("FPS:"+frames+"-------------------------------");
			    	 
                      fps=frames;
			    	//reset frame time and frames  
			    	  
			    	  frameTime=0;
			    	  frames=0;
			      }
			}
		
	}
private static void SpriteUpdate(Model player,Texture tex,float x,float y,float Playerscale,boolean mirror){
   s.bind();
   tex.bind(0);
   Matrix4f target=Math.getMatrix(new Vector2f(x/Playerscale,y/Playerscale),0,Playerscale);
   if(mirror==true)
   Math.mirror(target);
   
   s.loadInt(location, 0);
  	   s.loadMat(Projection,cam.getProjection());
       s.loadMat(RTS, target);
	player.draw();	 



}




	private static void initializeFPS() {
		time=Timer.getTIme();
		unproccesed=0;
	    frameTime=0;
	    frames=0;
		framCap=1.0/60;
		
		
	}

	
}
