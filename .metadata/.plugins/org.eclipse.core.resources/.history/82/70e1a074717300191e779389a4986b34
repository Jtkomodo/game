package gameEngine;
import java.io.IOException;
import static org.lwjgl.glfw.GLFW.*;
import java.util.Map;


import org.joml.Matrix4f;
import  org.joml.Vector2f;

import textrendering.Fontloader;
import textrendering.TextBuilder;
public class Start {
    
	
	public static Window w;
	public static final int width=640,height=480;
    public static int location,Projection,RTS,frames,j=0,i=0,fps;
    public static byte dKeys,testKey;
    public static ShaderProgram s;
    public static Camera cam;
    public static float screencoordx=0,screencoordy=0;
    public static Input I;
    public static Fontloader font;
    public static boolean canRender,overworld=true,test=false;
    public static double framCap,time,time2,passed,unproccesed,frameTime;
    public static Texture tex,MAP,bg,playerTex;
    public static float x2,y2,camx,camy,x,y,Playerscale=64;
    public static Model background,player;
    public static BatchedModel testM;
    public static TextBuilder textB,textA;
    
	public static void main(String[] args) {
		float[] vert={
				-0.5f,+0.5f,
				0.5f,0.5f,
				0.5f,-0.5f,
				-0.5f,-0.5f
			};
		
		
		
	
		
		
		
		float Texwidth=256;
		float Texheight=256;		
		float wi=64;
		float h=64;
		float Texx=64;
		float Texy=0;		
		
		float[] uv={
				Texx/Texwidth,Texy/Texheight,
				(Texx+wi)/Texwidth,Texy/Texheight,
				(Texx+wi)/Texwidth,(Texy+h)/Texheight,
				Texx/Texwidth,(Texy+h)/Texheight
				};
		
		
		float[] uvBg={
				0,0,
				1,0,
				1,1,
				0,1
				
				};
		
	
		
		
		
		
		
		
		
		
		
		
		
			
		int[] ind= {
			0,1,2,
			2,3,0	
				
		};
	   Texwidth=138;
	   Texheight=138;		
	   wi=32;
	   h=46;
	   Texx=0;
	   Texy=0;	
	   float height2=h/Playerscale;
	   float width2=wi/Playerscale;     
	 
	   float[] vertPlayer={
			   -width2,+height2,
				width2,height2,
				width2,-height2,
				-width2,-height2


	   };float[] vertPlayer2={
			  width2+ -width2,+height2,
				width2+width2,height2,
				width2+width2,-height2,
				width2+-width2,-height2


	   };


       float[] uvPlayer={
		Texx/Texwidth,Texy/Texheight,
		(Texx+wi)/Texwidth,Texy/Texheight,
		(Texx+wi)/Texwidth,(Texy+h)/Texheight,
		Texx/Texwidth,(Texy+h)/Texheight  };





		//for(int i=0;i<8;i++) {
		///System.out.println(uv[i]);
		//} 
		
		
		//make our window and attach shaders
		createWindow("shader");
	
		
		//Define texturesbr.close();
		//font=new Fontloader("aakar",512);    
		tex=new Texture("newsprite");
		bg= new Texture("testBackground");
	    textB= new TextBuilder("aakar",512); 
		textA= new TextBuilder("aakar",512);
		testM= new BatchedModel();
		
	//	MAP=new Texture("map3");
	    playerTex= new Texture("playerSprite2s_1");
		//map=new Texture("map1"); 
		//Define models
		Model m=new Model(vert,uv,ind);//model for tiles
		player= new Model(vertPlayer,uvPlayer,ind);
	    background=new Model(vert,uvBg,ind);
		
		
		//set camera
		cam= new Camera(width,height);
		
		//make shader locations so we can use uniforms
		try {
			location=s.makeLocation("sampler");
			Projection=s.makeLocation("projection");
			RTS=s.makeLocation("rts");
		} catch (Exception e) {
			
			e.printStackTrace();
		}
		WorldLoader worldLoader=new WorldLoader("map", 64,64, cam);
	
		
		Tiles t=new Tiles(tex, m, s, cam, location, Projection,RTS);
		
	    gameEngine.Map grid=new gameEngine.Map(worldLoader.Getmap(),t);
	
		
		
		
		 boolean map=true;
		initializeFPS();
		x=0;
		y=0;	
	for(int i=0;i<5;i++) {
		for(int j=0;j<5;j++) {
        float addi=(0.5f*i)*2;	
        float addj=(0.5f*j)*2;		
			 vert=new float[]{
						addj-0.5f,addi+0.5f,
						addj+0.5f,addi+0.5f,
						addj+0.5f,addi-0.5f,
						addj+-0.5f,addi-0.5f
					};
			    testM.addvaluestoVBO(vert,uv);
			
	}
	}
 
    //----------------------game loop------------------------------
		while(!w.isExited() && !I.IsEscapePushed()) {
	
		fps();
	    t.unbind();
	
	    
	if(canRender) {
	  // TextureUpdate(MAP)
Model.enable();
BatchedModel.enable();
		frames++;
		if(test==false) {
if(overworld==true) {		 
		 
	    screencoordx=-camx;
	    screencoordy=-camy;
		
	    		
	     cam.setPosition((new Vector2f(camx,camy)));s.bind();
	      
	     grid.Draw();
	   
	      textB.setString("x="+x+" y="+y);
		 //font.text("x="+x+" y="+y,screencoordx-300,screencoordy-220,.24f);//prints the x and y positions on the screen	  
		 SpriteUpdate(player,playerTex,x,y,Playerscale,true);
		textB.drawString(screencoordx-300,screencoordy-220,.24f);
}else {
	//---------------------battle loop---------------------
	battleupdate();
    screencoordx=0;
	screencoordy=0;
	
	
}
textA.setString("fps="+(int)fps);
textA.drawString((640/2)+screencoordx-100,(480/2)+screencoordy-20,.24f);

//font.text("fps="+(int)fps,(640/2)+screencoordx-100,(480/2)+screencoordy-20,.24f);

		}
		    w.render();
		    w.clear();
			
		}
		}
//--------------------------------------------------------------		
		
		w.destroy();
		
		
	}

	private static void TextureUpdate(Texture tex) {

		byte b=I.getDirectionalInput();
		
			if(b==0x0001) {
			try {
				System.out.println("yes");
				tex.createFile(true,"map");
			} catch (IOException e) {
			
				e.printStackTrace();
			}
		}
		}
		
		
		
	

	private static void createWindow(String Shader) {
	 w=new Window(width,height);
	 I=new Input(w);	
       //load our shaders 
		s= new ShaderProgram(Shader);
		//bind shader
		s.bind();	
		
		
	}

	private static void Inputupdate() {
		w.update();//this is needed to actually poll events from keyboard 
		I.findKeys();
	    dKeys=I.getDirectionalInput();
	    
	   testKey=I.getStateofButton(GLFW_KEY_T);
	   float speed=1;
	    		
		byte stateofFullscreen=I.stateOfFullscreen();
	      if(stateofFullscreen==1) {//if the fuscreenCode is just pressed toggle full screen
			 w.toggleFullscreen();}
		
	if(testKey==2) {
		if (overworld==false) {
			overworld=true;
			
		}else {
			overworld=false;
			
		}
		
	}
	
	
	if(overworld==true) {
		        if(I.getStateofButton(GLFW_KEY_W)==1 || I.getStateofButton(GLFW_KEY_W)==3) {
		        	speed=5;
		        	
		        	
		        }else {
		        	speed=1;
		        	
		        	
		        }
		
		
				if((dKeys>>4 &0x01)==1) {//if c is pushed
					if((dKeys & 0x01)==1) {//up
						camy-=10;

						
					}
					if((dKeys>>1 & 0b001)==1) {//down
						camy+=10;
						
					}if((dKeys>>2 & 0b001)==1) {//left
						camx-=10;
						
					}if((dKeys>>3 & 0b001)==1) {//right
						camx+=10;}	 
					}else{ 
						if((dKeys & 0x01)==1) {//up
							y+=5*speed;
							
						}
						if((dKeys>>1 & 0b001)==1) {//down
							y-=5*speed;
							
						}if((dKeys>>2 & 0b001)==1) {//left
							x+=5*speed;
							
						}if((dKeys>>3 & 0b001)==1) {//right
							x-=5*speed;}	 
					camx=-x;
					camy=-y;
					
						}
		 
	}
		 
		 
			 }
	
	
   private static void battleupdate() {
	   cam.setPosition(new Vector2f(0,0));
		s.bind();
		bg.bind(0);
		  s.loadInt(location, 0);
		  cam.setPosition(new Vector2f(0,0));
	 	   s.loadMat(Projection,cam.getProjection());
	 	  s.loadMat(RTS,Math.getMatrix(new Vector2f(0,0),0,64*40));//change rotation and scale with this
	 	  background.draw();
	 	  SpriteUpdate(player,playerTex,-192,-20,64*1.5f,true); //doing the same model and texture just for testing  will change that when we actually get the battle system down  
	 	  SpriteUpdate(player,playerTex,-222,-128-20,64*1.5f,true);
	 	  SpriteUpdate(player,playerTex,222-20,-128+40,64*1.5f,false);
	 	   s.loadInt(location, 0);
	   
	   
   }
	
	private static void fps() {
		    Model.disable();
		    canRender=false;//don't allow rendering until time
			time2=Timer.getTIme();//gets current time
		    passed=time2-time;//this is the time since the last time through the loop
			unproccesed+=passed;//this is the time that we have not rendered anything
			frameTime+=passed;//this is the time since the last second
			time=time2;
			while(unproccesed>=framCap) {//when the time we have not rendered is greater than or equal to our frame target we allow rendering
				
				unproccesed-=framCap;//this is like reseting but instead if it is way over for some reason it makes sure to allow all rendering missed 
			       
				//take input
				 Inputupdate();
			     canRender=true;//now we render	
			    
			      if(frameTime>=1.0) {//if a second has passed print fps
			    	 
			    	 // System.out.println("FPS:"+frames+"-------------------------------");
			    	 
                      fps=frames;
			    	//reset frame time and frames  
			    	  
			    	  frameTime=0;
			    	  frames=0;
			      }
			
			}
	}
private static void SpriteUpdate(Model player,Texture tex,float x,float y,float Playerscale,boolean mirror){
   s.bind();
   tex.bind(0);
   Matrix4f target=Math.getMatrix(new Vector2f(x/Playerscale,y/Playerscale),0,Playerscale);
   if(mirror==true)
   Math.mirror(target);
   
   s.loadInt(location, 0); 
  	   s.loadMat(Projection,cam.getProjection());
       s.loadMat(RTS, target);
	player.draw();	 
	/* Start.tex.bind(0);
	  target=Math.getMatrix(new Vector2f(cam.getPosition().x/128,cam.getPosition().y/128),0,128);
    
	  s.loadInt(location, 0); 
 	   s.loadMat(Projection,cam.getProjection());
      s.loadMat(RTS, target);
	testM.draw();	 
    */
    
    
    
    
    
    
    
}




	private static void initializeFPS() {
		time=Timer.getTIme();
		unproccesed=0;
	    frameTime=0;
	    frames=0;
		framCap=1.0/60.0;
		
		
	}

	
		
		
	
	
	
	
}
